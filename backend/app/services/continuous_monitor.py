"""
Continuous Portfolio Monitor - Real-Time Risk-Aware Trading System

This is the CORE component for the hackathon that implements:
"Continuous Decision-Making for Risk-Aware Trading"

Features:
1. Continuous monitoring of open positions (not just on-demand)
2. Real-time price updates from Yahoo Finance
3. Automatic risk reassessment as market conditions change
4. Proactive alerts when positions need attention
5. Capital efficiency tracking (detect idle/locked capital)
6. Opportunity scanning while managing existing positions
"""

import os
import sys
import time
import asyncio
import logging
from typing import Dict, Any, List, Optional, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import threading
from queue import Queue

import yfinance as yf

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from sqlalchemy.orm import Session
from storage.database import SessionLocal
from services.position_service import PositionService
from services.account_service import AccountService
from services.portfolio_risk_service import PortfolioRiskService, PositionAction, RiskLevel

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class AlertType(Enum):
    """Types of alerts the monitor can generate"""
    RISK_THRESHOLD = "risk_threshold"       # Position risk exceeds limit
    STOP_LOSS_HIT = "stop_loss_hit"         # Price hit stop loss
    TAKE_PROFIT = "take_profit"             # Price hit take profit target
    CONCENTRATION = "concentration"          # Position too concentrated
    IDLE_CAPITAL = "idle_capital"           # Too much cash sitting idle
    OPPORTUNITY = "opportunity"              # New opportunity detected
    REBALANCE = "rebalance"                 # Portfolio needs rebalancing
    VOLATILITY_SPIKE = "volatility_spike"   # Sudden volatility increase
    CORRELATION = "correlation"              # Positions too correlated


class ActionUrgency(Enum):
    """Urgency level for recommended actions"""
    IMMEDIATE = "immediate"     # Act now
    HIGH = "high"               # Act within hours
    MEDIUM = "medium"           # Act within day
    LOW = "low"                 # Monitor, act within week


@dataclass
class PositionUpdate:
    """Real-time update for a position"""
    symbol: str
    symbol_id: int
    prev_price: float
    current_price: float
    price_change_pct: float
    entry_price: float
    quantity: float
    unrealized_pnl: float
    unrealized_pnl_pct: float
    risk_level: RiskLevel
    recommended_action: PositionAction
    action_urgency: ActionUrgency
    reasons: List[str]
    timestamp: datetime


@dataclass 
class Alert:
    """Alert generated by the monitoring system"""
    alert_type: AlertType
    urgency: ActionUrgency
    symbol: Optional[str]
    title: str
    message: str
    data: Dict[str, Any]
    timestamp: datetime
    acknowledged: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "alert_type": self.alert_type.value,
            "urgency": self.urgency.value,
            "symbol": self.symbol,
            "title": self.title,
            "message": self.message,
            "data": self.data,
            "timestamp": self.timestamp.isoformat(),
            "acknowledged": self.acknowledged
        }


@dataclass
class PortfolioSnapshot:
    """Snapshot of portfolio state at a point in time"""
    timestamp: datetime
    total_value: float
    cash: float
    invested: float
    total_pnl: float
    total_pnl_pct: float
    risk_level: RiskLevel
    position_count: int
    positions: List[PositionUpdate]
    alerts: List[Alert]
    capital_efficiency: float  # % of capital productively deployed
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "timestamp": self.timestamp.isoformat(),
            "total_value": self.total_value,
            "cash": self.cash,
            "invested": self.invested,
            "total_pnl": self.total_pnl,
            "total_pnl_pct": self.total_pnl_pct,
            "risk_level": self.risk_level.value,
            "position_count": self.position_count,
            "positions": [
                {
                    "symbol": p.symbol,
                    "current_price": p.current_price,
                    "pnl_pct": p.unrealized_pnl_pct,
                    "risk_level": p.risk_level.value,
                    "action": p.recommended_action.value,
                    "urgency": p.action_urgency.value
                }
                for p in self.positions
            ],
            "alerts": [a.to_dict() for a in self.alerts],
            "capital_efficiency": self.capital_efficiency
        }


class ContinuousPortfolioMonitor:
    """
    Continuous monitoring system for risk-aware portfolio management.
    
    This is the core component that addresses the hackathon requirement:
    "Continuously assess risk, capital, and potential returns for open positions"
    """
    
    def __init__(
        self,
        account_id: str,
        check_interval_seconds: int = 60,
        on_alert: Optional[Callable[[Alert], None]] = None,
        on_update: Optional[Callable[[PortfolioSnapshot], None]] = None
    ):
        self.account_id = account_id
        self.check_interval = check_interval_seconds
        self.on_alert = on_alert
        self.on_update = on_update
        
        self._running = False
        self._thread: Optional[threading.Thread] = None
        self._alerts: List[Alert] = []
        self._position_history: Dict[str, List[PositionUpdate]] = {}
        self._last_snapshot: Optional[PortfolioSnapshot] = None
        
        # Risk thresholds (configurable)
        self.thresholds = {
            "max_position_loss_pct": -10.0,      # Alert if position down >10%
            "max_position_gain_pct": 25.0,        # Consider taking profits >25%
            "max_concentration_pct": 25.0,        # Max 25% in single position
            "max_idle_capital_pct": 40.0,         # Alert if >40% cash idle
            "max_portfolio_risk": 70,             # Risk score threshold
            "volatility_spike_threshold": 2.0,    # 2x normal volatility
        }
        
        # Price cache for rate limiting
        self._price_cache: Dict[str, Dict[str, Any]] = {}
        self._cache_ttl_seconds = 30
    
    def start(self):
        """Start continuous monitoring in background thread"""
        if self._running:
            logger.warning("Monitor already running")
            return
        
        self._running = True
        self._thread = threading.Thread(target=self._monitoring_loop, daemon=True)
        self._thread.start()
        logger.info(f"üöÄ Started continuous monitoring for account {self.account_id}")
    
    def stop(self):
        """Stop the monitoring loop"""
        self._running = False
        if self._thread:
            self._thread.join(timeout=5)
        logger.info(f"‚èπÔ∏è Stopped monitoring for account {self.account_id}")
    
    def _monitoring_loop(self):
        """Main monitoring loop - runs continuously"""
        while self._running:
            try:
                snapshot = self._check_portfolio()
                
                if self.on_update and snapshot:
                    self.on_update(snapshot)
                
                # Process any new alerts
                for alert in snapshot.alerts if snapshot else []:
                    if not alert.acknowledged and self.on_alert:
                        self.on_alert(alert)
                
                self._last_snapshot = snapshot
                
            except Exception as e:
                logger.error(f"Monitoring error: {e}")
            
            time.sleep(self.check_interval)
    
    def _check_portfolio(self) -> Optional[PortfolioSnapshot]:
        """Perform a single portfolio check"""
        db = SessionLocal()
        try:
            return self._assess_portfolio(db)
        finally:
            db.close()
    
    def _assess_portfolio(self, db: Session) -> PortfolioSnapshot:
        """Comprehensive portfolio assessment"""
        position_service = PositionService(db)
        account_service = AccountService(db)
        
        # Get account
        account = account_service.get_account_by_id(self.account_id)
        if not account:
            raise ValueError(f"Account {self.account_id} not found")
        
        # Get positions
        positions = position_service.get_positions_by_account(self.account_id)
        
        # Fetch real prices and assess each position
        position_updates = []
        alerts = []
        total_invested = 0.0
        total_pnl = 0.0
        
        for position in positions:
            if not position.quantity or position.quantity <= 0:
                continue
            
            # Get symbol
            symbol = position.symbol.ticker if hasattr(position, 'symbol') and position.symbol else f"SYM_{position.symbol_id}"
            
            # Fetch real price
            price_data = self._get_real_price(symbol)
            current_price = price_data.get('current_price', position.current_price or position.average_entry_price or 0)
            
            # Calculate position metrics
            quantity = float(position.quantity)
            entry_price = float(position.average_entry_price or current_price)
            prev_price = float(position.current_price or entry_price)
            
            market_value = quantity * current_price
            cost_basis = quantity * entry_price
            unrealized_pnl = market_value - cost_basis
            unrealized_pnl_pct = (unrealized_pnl / cost_basis * 100) if cost_basis > 0 else 0
            price_change_pct = ((current_price - prev_price) / prev_price * 100) if prev_price > 0 else 0
            
            total_invested += market_value
            total_pnl += unrealized_pnl
            
            # Assess risk and determine action
            risk_level, action, urgency, reasons = self._assess_position_risk(
                symbol, entry_price, current_price, unrealized_pnl_pct, 
                market_value, 0  # concentration calculated after totals
            )
            
            update = PositionUpdate(
                symbol=symbol,
                symbol_id=position.symbol_id,
                prev_price=prev_price,
                current_price=current_price,
                price_change_pct=price_change_pct,
                entry_price=entry_price,
                quantity=quantity,
                unrealized_pnl=unrealized_pnl,
                unrealized_pnl_pct=unrealized_pnl_pct,
                risk_level=risk_level,
                recommended_action=action,
                action_urgency=urgency,
                reasons=reasons,
                timestamp=datetime.now()
            )
            position_updates.append(update)
            
            # Generate alerts for this position
            position_alerts = self._generate_position_alerts(update)
            alerts.extend(position_alerts)
        
        # Calculate portfolio-level metrics
        cash = float(account.balance) if account.balance else 0
        total_value = total_invested + cash
        total_pnl_pct = (total_pnl / (total_value - total_pnl) * 100) if (total_value - total_pnl) > 0 else 0
        
        # Recalculate with concentration
        for update in position_updates:
            concentration = (update.quantity * update.current_price / total_value * 100) if total_value > 0 else 0
            if concentration > self.thresholds["max_concentration_pct"]:
                update.reasons.append(f"Concentration risk: {concentration:.1f}% of portfolio")
                if update.recommended_action == PositionAction.HOLD:
                    update.recommended_action = PositionAction.REDUCE
        
        # Calculate capital efficiency
        capital_efficiency = (total_invested / total_value * 100) if total_value > 0 else 0
        
        # Check for idle capital
        idle_capital_pct = (cash / total_value * 100) if total_value > 0 else 100
        if idle_capital_pct > self.thresholds["max_idle_capital_pct"]:
            alerts.append(Alert(
                alert_type=AlertType.IDLE_CAPITAL,
                urgency=ActionUrgency.MEDIUM,
                symbol=None,
                title="Idle Capital Warning",
                message=f"{idle_capital_pct:.1f}% of capital is sitting idle. Consider deploying to opportunities.",
                data={"idle_pct": idle_capital_pct, "cash": cash},
                timestamp=datetime.now()
            ))
        
        # Determine overall portfolio risk
        if position_updates:
            critical_count = sum(1 for p in position_updates if p.risk_level == RiskLevel.CRITICAL)
            high_count = sum(1 for p in position_updates if p.risk_level == RiskLevel.HIGH)
            
            if critical_count > 0:
                overall_risk = RiskLevel.CRITICAL
            elif high_count > len(position_updates) * 0.3:
                overall_risk = RiskLevel.HIGH
            elif high_count > 0:
                overall_risk = RiskLevel.MODERATE
            else:
                overall_risk = RiskLevel.LOW
        else:
            overall_risk = RiskLevel.LOW
        
        # Check if rebalancing needed
        actions_needed = [p for p in position_updates if p.recommended_action != PositionAction.HOLD]
        if len(actions_needed) > len(position_updates) * 0.3:
            alerts.append(Alert(
                alert_type=AlertType.REBALANCE,
                urgency=ActionUrgency.HIGH,
                symbol=None,
                title="Portfolio Rebalancing Needed",
                message=f"{len(actions_needed)} positions need attention. Consider rebalancing.",
                data={"positions_needing_action": len(actions_needed)},
                timestamp=datetime.now()
            ))
        
        # Store alerts
        self._alerts.extend(alerts)
        
        return PortfolioSnapshot(
            timestamp=datetime.now(),
            total_value=total_value,
            cash=cash,
            invested=total_invested,
            total_pnl=total_pnl,
            total_pnl_pct=total_pnl_pct,
            risk_level=overall_risk,
            position_count=len(position_updates),
            positions=position_updates,
            alerts=alerts,
            capital_efficiency=capital_efficiency
        )
    
    def _get_real_price(self, symbol: str) -> Dict[str, Any]:
        """Get real price with caching"""
        now = datetime.now()
        
        # Check cache
        if symbol in self._price_cache:
            cached = self._price_cache[symbol]
            if (now - cached['timestamp']).total_seconds() < self._cache_ttl_seconds:
                return cached['data']
        
        # Fetch fresh price
        try:
            ticker = yf.Ticker(symbol)
            info = ticker.info
            data = {
                'current_price': info.get('currentPrice') or info.get('regularMarketPrice') or 0,
                'prev_close': info.get('previousClose') or 0,
                'day_high': info.get('dayHigh') or 0,
                'day_low': info.get('dayLow') or 0,
            }
            self._price_cache[symbol] = {'data': data, 'timestamp': now}
            return data
        except Exception as e:
            logger.error(f"Error fetching price for {symbol}: {e}")
            return {'current_price': 0}
    
    def _assess_position_risk(
        self,
        symbol: str,
        entry_price: float,
        current_price: float,
        pnl_pct: float,
        market_value: float,
        concentration: float
    ) -> tuple:
        """Assess risk for a single position and determine action"""
        reasons = []
        
        # Determine risk level
        if pnl_pct < -20:
            risk_level = RiskLevel.CRITICAL
            reasons.append(f"Critical loss: {pnl_pct:.1f}%")
        elif pnl_pct < self.thresholds["max_position_loss_pct"]:
            risk_level = RiskLevel.HIGH
            reasons.append(f"Significant loss: {pnl_pct:.1f}%")
        elif pnl_pct > self.thresholds["max_position_gain_pct"]:
            risk_level = RiskLevel.MODERATE
            reasons.append(f"Large gain at risk: {pnl_pct:.1f}%")
        elif concentration > self.thresholds["max_concentration_pct"]:
            risk_level = RiskLevel.HIGH
            reasons.append(f"Over-concentrated: {concentration:.1f}%")
        else:
            risk_level = RiskLevel.LOW
        
        # Determine action
        if risk_level == RiskLevel.CRITICAL:
            action = PositionAction.EXIT
            urgency = ActionUrgency.IMMEDIATE
            reasons.append("Recommend full exit to stop losses")
        elif pnl_pct < self.thresholds["max_position_loss_pct"]:
            action = PositionAction.REDUCE
            urgency = ActionUrgency.HIGH
            reasons.append("Reduce exposure to limit further losses")
        elif pnl_pct > self.thresholds["max_position_gain_pct"]:
            action = PositionAction.REDUCE
            urgency = ActionUrgency.MEDIUM
            reasons.append("Consider taking partial profits")
        elif concentration > self.thresholds["max_concentration_pct"]:
            action = PositionAction.REDUCE
            urgency = ActionUrgency.MEDIUM
            reasons.append("Reduce to improve diversification")
        else:
            action = PositionAction.HOLD
            urgency = ActionUrgency.LOW
            reasons.append("Position within acceptable parameters")
        
        return risk_level, action, urgency, reasons
    
    def _generate_position_alerts(self, update: PositionUpdate) -> List[Alert]:
        """Generate alerts for a position update"""
        alerts = []
        
        # Stop loss alert
        if update.unrealized_pnl_pct < self.thresholds["max_position_loss_pct"]:
            alerts.append(Alert(
                alert_type=AlertType.STOP_LOSS_HIT,
                urgency=ActionUrgency.IMMEDIATE if update.unrealized_pnl_pct < -15 else ActionUrgency.HIGH,
                symbol=update.symbol,
                title=f"‚ö†Ô∏è {update.symbol} Stop Loss Alert",
                message=f"{update.symbol} is down {update.unrealized_pnl_pct:.1f}%. Consider exiting or reducing.",
                data={"pnl_pct": update.unrealized_pnl_pct, "current_price": update.current_price},
                timestamp=datetime.now()
            ))
        
        # Take profit alert
        if update.unrealized_pnl_pct > self.thresholds["max_position_gain_pct"]:
            alerts.append(Alert(
                alert_type=AlertType.TAKE_PROFIT,
                urgency=ActionUrgency.MEDIUM,
                symbol=update.symbol,
                title=f"üí∞ {update.symbol} Take Profit Opportunity",
                message=f"{update.symbol} is up {update.unrealized_pnl_pct:.1f}%. Consider taking some profits.",
                data={"pnl_pct": update.unrealized_pnl_pct, "current_price": update.current_price},
                timestamp=datetime.now()
            ))
        
        # Risk threshold alert
        if update.risk_level == RiskLevel.CRITICAL:
            alerts.append(Alert(
                alert_type=AlertType.RISK_THRESHOLD,
                urgency=ActionUrgency.IMMEDIATE,
                symbol=update.symbol,
                title=f"üî¥ {update.symbol} Critical Risk",
                message=f"{update.symbol} has reached critical risk level. Immediate action recommended.",
                data={"risk_level": update.risk_level.value, "action": update.recommended_action.value},
                timestamp=datetime.now()
            ))
        
        return alerts
    
    def get_current_state(self) -> Optional[PortfolioSnapshot]:
        """Get the last snapshot (for on-demand queries)"""
        if not self._last_snapshot:
            return self._check_portfolio()
        return self._last_snapshot
    
    def get_alerts(self, unacknowledged_only: bool = True) -> List[Alert]:
        """Get current alerts"""
        if unacknowledged_only:
            return [a for a in self._alerts if not a.acknowledged]
        return self._alerts
    
    def acknowledge_alert(self, index: int):
        """Acknowledge an alert"""
        if 0 <= index < len(self._alerts):
            self._alerts[index].acknowledged = True
    
    def get_action_summary(self) -> Dict[str, List[str]]:
        """Get summary of recommended actions"""
        if not self._last_snapshot:
            return {}
        
        summary = {
            "exit": [],
            "reduce": [],
            "hold": [],
            "add": []
        }
        
        for pos in self._last_snapshot.positions:
            action = pos.recommended_action.value
            summary[action].append(f"{pos.symbol} ({pos.unrealized_pnl_pct:+.1f}%)")
        
        return summary


# ==================== API INTEGRATION ====================

def create_monitor_for_account(account_id: str, interval: int = 60) -> ContinuousPortfolioMonitor:
    """Factory function to create a monitor for an account"""
    
    def on_alert(alert: Alert):
        logger.info(f"üö® ALERT [{alert.urgency.value}]: {alert.title}")
        logger.info(f"   {alert.message}")
    
    def on_update(snapshot: PortfolioSnapshot):
        logger.info(f"üìä Portfolio Update: {snapshot.position_count} positions, "
                   f"P&L: ${snapshot.total_pnl:+,.2f} ({snapshot.total_pnl_pct:+.1f}%), "
                   f"Risk: {snapshot.risk_level.value}")
    
    return ContinuousPortfolioMonitor(
        account_id=account_id,
        check_interval_seconds=interval,
        on_alert=on_alert,
        on_update=on_update
    )


# ==================== DEMO / TEST ====================

if __name__ == "__main__":
    print("üöÄ Starting Continuous Portfolio Monitor Demo")
    print("=" * 50)
    
    # Create monitor for demo account
    monitor = create_monitor_for_account("namo", interval=30)
    
    # Get initial state
    print("\nüìä Initial Portfolio State:")
    snapshot = monitor.get_current_state()
    if snapshot:
        print(f"   Total Value: ${snapshot.total_value:,.2f}")
        print(f"   Cash: ${snapshot.cash:,.2f}")
        print(f"   Invested: ${snapshot.invested:,.2f}")
        print(f"   P&L: ${snapshot.total_pnl:+,.2f} ({snapshot.total_pnl_pct:+.1f}%)")
        print(f"   Risk Level: {snapshot.risk_level.value}")
        print(f"   Capital Efficiency: {snapshot.capital_efficiency:.1f}%")
        
        print(f"\nüìã Positions ({snapshot.position_count}):")
        for pos in snapshot.positions:
            action_emoji = {"hold": "‚è∏Ô∏è", "reduce": "üìâ", "exit": "üö™", "add": "‚ûï"}.get(pos.recommended_action.value, "‚Ä¢")
            print(f"   {action_emoji} {pos.symbol}: ${pos.current_price:.2f} ({pos.unrealized_pnl_pct:+.1f}%) - {pos.recommended_action.value.upper()}")
        
        if snapshot.alerts:
            print(f"\nüö® Alerts ({len(snapshot.alerts)}):")
            for alert in snapshot.alerts:
                print(f"   [{alert.urgency.value}] {alert.title}")
    
    # Start continuous monitoring
    print("\n‚è±Ô∏è Starting continuous monitoring (Ctrl+C to stop)...")
    monitor.start()
    
    try:
        while True:
            time.sleep(10)
            actions = monitor.get_action_summary()
            if any(actions.values()):
                print(f"\nüìã Action Summary:")
                for action, symbols in actions.items():
                    if symbols:
                        print(f"   {action.upper()}: {', '.join(symbols)}")
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Stopping monitor...")
        monitor.stop()
        print("Done!")
